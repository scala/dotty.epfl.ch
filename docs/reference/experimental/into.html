<!DOCTYPE html><html data-githubContributorsUrl="https://api.github.com/repos/scala/scala3" data-githubContributorsFilename="/docs/_docs/reference/experimental/into.md" data-pathToRoot="../../../" data-rawLocation="docs/reference/experimental/into" data-dynamicSideMenu="false"><head><meta charset="utf-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"></meta><title>The `into` Type and Modifier</title><link rel="shortcut icon" type="image/x-icon" href="../../../favicon.ico"></link><script type="text/javascript" src="../../../scripts/theme.js"></script><script type="text/javascript" src="../../../scripts/searchData.js" defer="true"></script><script type="text/javascript" src="../../../scripts/scastieConfiguration.js" defer="true"></script><link rel="stylesheet" href="../../../styles/theme/bundle.css"></link><link rel="stylesheet" href="../../../styles/theme/components/bundle.css"></link><link rel="stylesheet" href="../../../styles/theme/components/button/bundle.css"></link><link rel="stylesheet" href="../../../styles/theme/layout/bundle.css"></link><link rel="stylesheet" href="../../../styles/nord-light.css"></link><link rel="stylesheet" href="../../../styles/dotty-icons.css"></link><link rel="stylesheet" href="../../../styles/filter-bar.css"></link><link rel="stylesheet" href="../../../styles/code-snippets.css"></link><link rel="stylesheet" href="../../../styles/searchbar.css"></link><link rel="stylesheet" href="../../../styles/social-links.css"></link><link rel="stylesheet" href="../../../styles/versions-dropdown.css"></link><link rel="stylesheet" href="../../../styles/content-contributors.css"></link><link rel="stylesheet" href="../../../styles/fontawesome.css"></link><script type="text/javascript" src="../../../hljs/highlight.pack.js" defer="true"></script><script type="text/javascript" src="../../../scripts/hljs-scala3.js" defer="true"></script><script type="text/javascript" src="../../../scripts/ux.js" defer="true"></script><script type="text/javascript" src="../../../scripts/common/component.js" defer="true"></script><script type="text/javascript" src="../../../scripts/common/utils.js" defer="true"></script><script type="text/javascript" src="../../../scripts/components/FilterBar.js" defer="true"></script><script type="text/javascript" src="../../../scripts/components/DocumentableList.js" defer="true"></script><script type="text/javascript" src="../../../scripts/components/Input.js" defer="true"></script><script type="text/javascript" src="../../../scripts/components/FilterGroup.js" defer="true"></script><script type="text/javascript" src="../../../scripts/components/Filter.js" defer="true"></script><script type="text/javascript" src="../../../scripts/scaladoc-scalajs.js" defer="true"></script><script type="text/javascript" src="../../../scripts/contributors.js" defer="true"></script><script type="text/javascript" src="https://code.jquery.com/jquery-3.5.1.min.js" defer="true"></script><script type="text/javascript" src="https://d3js.org/d3.v6.min.js" defer="true"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/graphlib-dot@0.6.2/dist/graphlib-dot.min.js" defer="true"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dagre-d3/0.6.1/dagre-d3.min.js" defer="true"></script><script type="text/javascript" src="https://scastie.scala-lang.org/embedded.js" defer="true"></script><script type="text/javascript" src="../../../scripts/data.js" defer="true"></script><link rel="stylesheet" href="../../../styles/staticsitestyles.css"></link><script>var pathToRoot = "../../../";</script><script>var versionsDictionaryUrl = "https://scala-lang.org/api/versions.json";</script><link rel="dns-prefetch" href="//fonts.googleapis.com">
<link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="stylesheet" href="/css/dottydoc.css"></head><body><div id=""><div id="header" class="body-small"><div class="header-container-left"><a href="../../../" class="logo-container"><span id="project-logo" class="project-logo"><img src="../../../project-logo/logo.svg"></img></span><span id="dark-project-logo" class="project-logo"><img src="../../../project-logo/logo_dark.svg"></img></span><span class="project-name h300">Scala 3</span></a><span onclick="dropdownHandler(event)" class="text-button with-arrow" id="dropdown-trigger"><a><div class="projectVersion">3.8.0-RC1-bin-20250730-d7f3a80-NIGHTLY</div></a></span><div id="version-dropdown" class="dropdown-menu"></div></div><div class="header-container-right"><button id="search-toggle" class="icon-button"></button><a href="https://docs.scala-lang.org/" class="text-button">Learn</a><a href="https://www.scala-lang.org/download/" class="text-button">Install</a><a href="https://scastie.scala-lang.org" class="text-button">Playground</a><a href="https://index.scala-lang.org" class="text-button">Find A Library</a><a href="https://www.scala-lang.org/community/" class="text-button">Community</a><a href="https://www.scala-lang.org/blog/" class="text-button">Blog</a><span id="theme-toggle" class="icon-button"></span><span id="mobile-menu-toggle" class="icon-button hamburger"></span></div></div><div id="mobile-menu"><div class="mobile-menu-header body-small"><span class="mobile-menu-logo"><span id="project-logo" class="project-logo"><img src="../../../project-logo/logo.svg"></img></span><span id="dark-project-logo" class="project-logo"><img src="../../../project-logo/logo_dark.svg"></img></span><span class="project-name h300">Scala 3</span></span><button id="mobile-menu-close" class="icon-button close"></button></div><div class="mobile-menu-container body-medium"><input id="mobile-scaladoc-searchbar-input" class="scaladoc-searchbar-input" type="search" placeholder="Find anything"></input><a href="https://docs.scala-lang.org/" class="mobile-menu-item">Learn</a><a href="https://www.scala-lang.org/download/" class="mobile-menu-item">Install</a><a href="https://scastie.scala-lang.org" class="mobile-menu-item">Playground</a><a href="https://index.scala-lang.org" class="mobile-menu-item">Find A Library</a><a href="https://www.scala-lang.org/community/" class="mobile-menu-item">Community</a><a href="https://www.scala-lang.org/blog/" class="mobile-menu-item">Blog</a><span id="mobile-theme-toggle" class="mobile-menu-item mode"></span></div></div><span id="mobile-sidebar-toggle" class="floating-button"></span><div id="leftColumn" class="body-small"><div class="switcher-container"><a id="docs-nav-button" class="switcher h100 selected" href="../../../index.html">Docs</a><a id="api-nav-button" class="switcher h100 " href="../../../api/index.html">API</a></div><nav id="docs-nav" class="side-menu"><div class="ni n0 expanded"><span class="nh h100 expanded cs de"><button class="ar icon-button expanded"></button><a href="../index.html"><span>Reference</span></a></span><div class="ni n1"><span class="nh de"><button class="ar icon-button "></button><a href="../new-types/index.html"><span>New Types</span></a></span><div class="ni n2 "><span class="nh de"><a href="../new-types/intersection-types.html"><span>Intersection Types</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../new-types/union-types.html"><span>Union Types</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../new-types/type-lambdas.html"><span>Type Lambdas</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../new-types/match-types.html"><span>Match Types</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../new-types/dependent-function-types.html"><span>Dependent Function Types</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../new-types/polymorphic-function-types.html"><span>Polymorphic Function Types</span></a></span></div></div><div class="ni n1"><span class="nh de"><button class="ar icon-button "></button><a href="../enums/index.html"><span>Enums</span></a></span><div class="ni n2 "><span class="nh de"><a href="../enums/enums.html"><span>Enumerations</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../enums/adts.html"><span>Algebraic Data Types</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../enums/desugarEnums.html"><span>Translation of Enums and ADTs</span></a></span></div></div><div class="ni n1"><span class="nh de"><button class="ar icon-button "></button><a href="../contextual/index.html"><span>Contextual Abstractions</span></a></span><div class="ni n2 "><span class="nh de"><a href="../contextual/givens.html"><span>Given Instances</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../contextual/using-clauses.html"><span>Using Clauses</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../contextual/context-bounds.html"><span>Context Bounds</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../contextual/deferred-givens.html"><span>Deferred Givens</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../contextual/given-imports.html"><span>Importing Givens</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../contextual/more-givens.html"><span>Other Forms Of Givens</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../contextual/extension-methods.html"><span>Extension Methods</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../contextual/right-associative-extension-methods.html"><span>Right-Associative Extension Methods: Details</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../contextual/type-classes.html"><span>Implementing Type classes</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../contextual/derivation.html"><span>Type Class Derivation</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../contextual/derivation-macro.html"><span>How to write a type class `derived` method using macros</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../contextual/multiversal-equality.html"><span>Multiversal Equality</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../contextual/context-functions.html"><span>Context Functions</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../contextual/conversions.html"><span>Implicit Conversions</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../contextual/by-name-context-parameters.html"><span>By-Name Context Parameters</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../contextual/relationship-implicits.html"><span>Relationship with Scala 2 Implicits</span></a></span></div></div><div class="ni n1"><span class="nh de"><button class="ar icon-button "></button><a href="../metaprogramming/index.html"><span>Metaprogramming</span></a></span><div class="ni n2 "><span class="nh de"><a href="../metaprogramming/inline.html"><span>Inline</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../metaprogramming/compiletime-ops.html"><span>Compile-time operations</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../metaprogramming/macros.html"><span>Macros</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../metaprogramming/simple-smp.html"><span>The Meta-theory of Symmetric Metaprogramming</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../metaprogramming/staging.html"><span>Run-Time Multi-Stage Programming</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../metaprogramming/reflection.html"><span>Reflection</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../metaprogramming/tasty-inspect.html"><span>TASTy Inspection</span></a></span></div></div><div class="ni n1"><span class="nh de"><button class="ar icon-button "></button><a href="../other-new-features/index.html"><span>Other New Features</span></a></span><div class="ni n2 "><span class="nh de"><a href="../other-new-features/trait-parameters.html"><span>Trait Parameters</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../other-new-features/transparent-traits.html"><span>Transparent Traits and Classes</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../other-new-features/creator-applications.html"><span>Universal Apply Methods</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../other-new-features/export.html"><span>Export Clauses</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../other-new-features/opaques.html"><span>Opaque Type Aliases</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../other-new-features/opaques-details.html"><span>Opaque Type Aliases: More Details</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../other-new-features/named-tuples.html"><span>Named Tuples</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../other-new-features/open-classes.html"><span>Open Classes</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../other-new-features/parameter-untupling.html"><span>Parameter Untupling</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../other-new-features/kind-polymorphism.html"><span>Kind Polymorphism</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../other-new-features/matchable.html"><span>The Matchable Trait</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../other-new-features/threadUnsafe-annotation.html"><span>The @threadUnsafe annotation</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../other-new-features/targetName.html"><span>The @targetName annotation</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../other-new-features/control-syntax.html"><span>New Control Syntax</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../other-new-features/indentation.html"><span>Optional Braces</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../other-new-features/safe-initialization.html"><span>Safe Initialization</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../other-new-features/type-test.html"><span>TypeTest</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../other-new-features/experimental-defs.html"><span>Experimental Definitions</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../other-new-features/preview-defs.html"><span>Preview Definitions</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../other-new-features/binary-literals.html"><span>Binary Integer Literals</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../other-new-features/toplevel-definitions.html"><span>Toplevel Definitions</span></a></span></div></div><div class="ni n1"><span class="nh de"><button class="ar icon-button "></button><a href="../changed-features/index.html"><span>Other Changed Features</span></a></span><div class="ni n2 "><span class="nh de"><a href="../changed-features/numeric-literals.html"><span>Numeric Literals</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../changed-features/structural-types.html"><span>Programmatic Structural Types</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../changed-features/operators.html"><span>Rules for Operators</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../changed-features/wildcards.html"><span>Wildcard Arguments in Types</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../changed-features/imports.html"><span>Imports</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../changed-features/type-inference.html"><span>Changes in Type Inference</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../changed-features/implicit-resolution.html"><span>Changes in Implicit Resolution</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../changed-features/implicit-conversions.html"><span>Implicit Conversions</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../changed-features/overload-resolution.html"><span>Changes in Overload Resolution</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../changed-features/match-syntax.html"><span>Match Expressions</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../changed-features/vararg-splices.html"><span>Vararg Splices</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../changed-features/pattern-bindings.html"><span>Pattern Bindings</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../changed-features/pattern-matching.html"><span>Option-less pattern matching</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../changed-features/eta-expansion.html"><span>Automatic Eta Expansion</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../changed-features/compiler-plugins.html"><span>Changes in Compiler Plugins</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../changed-features/lazy-vals-init.html"><span>Lazy Vals Initialization</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../changed-features/main-functions.html"><span>Main Methods</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../changed-features/interpolation-escapes.html"><span>Escapes in interpolations</span></a></span></div></div><div class="ni n1"><span class="nh de"><button class="ar icon-button "></button><a href="../dropped-features/index.html"><span>Dropped Features</span></a></span><div class="ni n2 "><span class="nh de"><a href="../dropped-features/delayed-init.html"><span>Dropped: DelayedInit</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../dropped-features/macros.html"><span>Dropped: Scala 2 Macros</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../dropped-features/existential-types.html"><span>Dropped: Existential Types</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../dropped-features/type-projection.html"><span>Dropped: General Type Projection</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../dropped-features/do-while.html"><span>Dropped: Do-While</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../dropped-features/procedure-syntax.html"><span>Dropped: Procedure Syntax</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../dropped-features/early-initializers.html"><span>Dropped: Early Initializers</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../dropped-features/class-shadowing.html"><span>Dropped: Class Shadowing</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../dropped-features/limit22.html"><span>Dropped: Limit 22</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../dropped-features/xml.html"><span>Dropped: XML Literals</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../dropped-features/symlits.html"><span>Dropped: Symbol Literals</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../dropped-features/auto-apply.html"><span>Dropped: Auto-Application</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../dropped-features/weak-conformance.html"><span>Dropped: Weak Conformance</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../dropped-features/nonlocal-returns.html"><span>Deprecated: Nonlocal Returns</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../dropped-features/this-qualifier.html"><span>Dropped: private[this] and protected[this]</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../dropped-features/wildcard-init.html"><span>Dropped: Wildcard Initializer</span></a></span></div></div><div class="ni n1"><span class="nh de"><button class="ar icon-button "></button><a href="../preview/index.html"><span>Preview</span></a></span><div class="ni n2 "><span class="nh de"><a href="../preview/better-fors.html"><span>Better fors</span></a></span></div></div><div class="ni n1 expanded"><span class="nh h100 expanded cs de"><button class="ar icon-button expanded"></button><a href="index.html"><span>Experimental</span></a></span><div class="ni n2 "><span class="nh de"><a href="canthrow.html"><span>CanThrow Capabilities</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="erased-defs.html"><span>Erased Definitions</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="named-typeargs.html"><span>Named Type Arguments</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="numeric-literals.html"><span>Numeric Literals</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="explicit-nulls.html"><span>Explicit Nulls</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="main-annotation.html"><span>MainAnnotation</span></a></span></div><div class="ni n2 expanded"><span class="nh h100 selected de"><a href="#"><span>The `into` Type and Modifier</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="cc.html"><span>Capture Checking</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="purefuns.html"><span>Pure Function Syntax</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="tupled-function.html"><span>Tupled Function</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="modularity.html"><span>Modularity Improvements</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="typeclasses.html"><span>Better Support for Type Classes</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="runtimeChecked.html"><span>The runtimeChecked method</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="unrolled-defs.html"><span>Automatic Parameter Unrolling</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="package-object-values.html"><span>Reference-able Package Objects</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="quoted-patterns-with-polymorphic-functions.html"><span>Quoted Patterns with Polymorphic Functions</span></a></span></div></div><div class="ni n1 "><span class="nh de"><a href="../syntax.html"><span>Scala 3 Syntax Summary</span></a></span></div><div class="ni n1"><span class="nh de"><button class="ar icon-button "></button><a href="../language-versions/index.html"><span>Language Versions</span></a></span><div class="ni n2 "><span class="nh de"><a href="../language-versions/source-compatibility.html"><span>Source Compatibility</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../language-versions/binary-compatibility.html"><span>Binary Compatibility</span></a></span></div></div><div class="ni n1 "><span class="nh de"><a href="../soft-modifier.html"><span>Soft Keywords</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../features-classification.html"><span>A Classification of Proposed Language Features</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../../contributing/index.html"><span>Contributing</span></a></span><div class="ni n1 "><span class="nh de"><a href="../../contributing/getting-started.html"><span>Getting Started</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../../contributing/setting-up-your-ide.html"><span>Setting up your IDE</span></a></span></div><div class="ni n1"><span class="nh de"><button class="ar icon-button "></button><a href="../../contributing/diagnosing-your-issue/index.html"><span>Diagnosing your issue</span></a></span><div class="ni n2 "><span class="nh de"><a href="../../contributing/diagnosing-your-issue/reproduce.html"><span>Reproducing an Issue</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../../contributing/diagnosing-your-issue/cause.html"><span>Finding the Cause of an Issue</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../../contributing/diagnosing-your-issue/areas.html"><span>Common Issue Locations</span></a></span></div></div><div class="ni n1"><span class="nh de"><button class="ar icon-button "></button><a href="../../contributing/debugging-the-compiler/index.html"><span>Debugging the Compiler</span></a></span><div class="ni n2 "><span class="nh de"><a href="../../contributing/debugging-the-compiler/ide-debugging.html"><span>Debugging with your IDE</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../../contributing/debugging-the-compiler/inspection.html"><span>How to Inspect Values</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../../contributing/debugging-the-compiler/other-debugging.html"><span>Other Debugging Techniques</span></a></span></div></div><div class="ni n1 "><span class="nh de"><a href="../../contributing/testing.html"><span>Testing Your Changes</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../../contributing/scaladoc.html"><span>Scaladoc</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../../contributing/community-build.html"><span>Community Build</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../../contributing/sending-in-a-pr.html"><span>Sending in a pull request</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../../contributing/cheatsheet.html"><span>Command Cheatsheet</span></a></span></div><div class="ni n1"><span class="nh de"><button class="ar icon-button "></button><a href="../../contributing/procedures/index.html"><span>Procedures</span></a></span><div class="ni n2 "><span class="nh de"><a href="../../contributing/procedures/release.html"><span>Release Procedure</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../../contributing/procedures/vulpix.html"><span>Test Vulpix Framework</span></a></span></div></div><div class="ni n1"><span class="nh de"><button class="ar icon-button "></button><a href="../../contributing/architecture/index.html"><span>High Level Architecture</span></a></span><div class="ni n2 "><span class="nh de"><a href="../../contributing/architecture/lifecycle.html"><span>Compiler Overview</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../../contributing/architecture/context.html"><span>Contexts</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../../contributing/architecture/phases.html"><span>Compiler Phases</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../../contributing/architecture/types.html"><span>Compiler Types</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../../contributing/architecture/time.html"><span>Time in the Compiler</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="../../contributing/architecture/symbols.html"><span>Symbols</span></a></span></div></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../../internals/index.html"><span>Internals</span></a></span><div class="ni n1 "><span class="nh de"><a href="../../internals/backend.html"><span>Backend Internals</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../../internals/classpaths.html"><span>Classpaths</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../../internals/contexts.html"><span>Contexts</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../../internals/dotc-scalac.html"><span>Differences between Scalac and Dotty</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../../internals/higher-kinded-v2.html"><span>Higher-Kinded Types in Dotty</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../../internals/overall-structure.html"><span>Dotty Overall Structure</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../../internals/explicit-nulls.html"><span>Explicit Nulls</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../../internals/periods.html"><span>Dotc&apos;s concept of time</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../../internals/syntax.html"><span>Scala 3 Syntax Summary</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../../internals/type-system.html"><span>Type System</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../../internals/dotty-internals-1-notes.html"><span>Dotty Internals 1: Trees &amp; Symbols (Meeting Notes)</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../../internals/debug-macros.html"><span>Debug Macros</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../../internals/gadts.html"><span>GADTs - Broad overview</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../../internals/coverage.html"><span>Code Coverage for Scala 3</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../../internals/best-effort-compilation.html"><span>Best Effort Compilation</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../../../blog/index.html"><span>Blog (archive)</span></a></span><div class="ni n1 "><span class="nh de"><a href="../../../blog/2021/06/25/scala301-rc2.html"><span>Scala 3.0.1-RC2 – backports of critical bugfixes</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../../../blog/2021/06/07/scala3.0.1-rc1-release.html"><span>Scala 3.0.1-RC1 – further stabilising the compiler</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../../../blog/2021/04/21/scala3-rc3.html"><span>Scala 3.0.0-RC3 – bug fixes for 3.0.0 stable</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../../../blog/2021/03/31/scala3-rc2.html"><span>Scala 3.0.0-RC2 – getting ready for 3.0.0</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../../../blog/2021/02/17/scala3-rc1.html"><span>Scala 3.0.0-RC1 – first release candidate is here</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../../../blog/2020/12/18/scala3-m3.html"><span>Scala 3.0.0-M3: developer&apos;s preview before RC1</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../../../blog/2020/11/09/scala3-m1.html"><span>Scala 3.0.0-M1 is here</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../../../blog/2020/09/21/naming-schema-change.html"><span>Dotty becomes Scala 3</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../../../blog/2020/08/31/27th-dotty-milestone-release.html"><span>Announcing Dotty 0.27.0-RC1 - ScalaJS, performance, stability</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../../../blog/2020/07/27/26th-dotty-milestone-release.html"><span>Announcing Dotty 0.26.0-RC1 - unified extension methods and more</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../../../blog/2020/06/22/25th-dotty-milestone-release.html"><span>Announcing Dotty 0.25.0-RC2 - speed-up of givens and change in the tuple API</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../../../blog/2020/04/29/24th-dotty-milestone-release.html"><span>Announcing Dotty 0.24.0-RC1 - 2.13.2 standard library, better error messages and more</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../../../blog/2020/03/18/23rd-dotty-milestone-release.html"><span>Announcing Dotty 0.23.0-RC1 - safe initialization checks, type-level bitwise operations and more</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../../../blog/2020/02/05/22nd-dotty-milestone-release.html"><span>Announcing Dotty 0.22.0-RC1 - syntactic enhancements, type-level arithmetic and more</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../../../blog/2019/12/20/21th-dotty-milestone-release.html"><span>Announcing Dotty 0.21.0-RC1 - explicit nulls, new syntax for `match` and conditional givens, and more</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../../../blog/2019/11/04/20th-dotty-milestone-release.html"><span>Announcing Dotty 0.20.0-RC1 – `with` starting indentation blocks, inline given specializations and more</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../../../blog/2019/09/23/19th-dotty-milestone-release.html"><span>Announcing Dotty 0.19.0-RC1 – further refinements of the syntax and the migration to 2.13.1 standard library</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../../../blog/2019/08/30/18th-dotty-milestone-release.html"><span>Announcing Dotty 0.18.1-RC1 – switch to the 2.13 standard library, indentation-based syntax and other experiments</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../../../blog/2019/07/25/17th-dotty-milestone-release.html"><span>Announcing Dotty 0.17.0-RC1 – new implicit scoping rules and more</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../../../blog/2019/06/11/16th-dotty-milestone-release.html"><span>Announcing Dotty 0.16.0-RC3 – the Scala Days 2019 Release</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../../../blog/2019/05/23/15th-dotty-milestone-release.html"><span>Announcing Dotty 0.15.0-RC1 – the fully bootstrapped compiler</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../../../blog/2019/04/15/14th-dotty-milestone-release.html"><span>Announcing Dotty 0.14.0-RC1 with export, immutable arrays, creator applications and more</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../../../blog/2019/03/05/13th-dotty-milestone-release.html"><span>Announcing Dotty 0.13.0-RC1 with Spark support, top level definitions and redesigned implicits</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../../../blog/2019/01/21/12th-dotty-milestone-release.html"><span>Announcing Dotty 0.12.0-RC1</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../../../blog/2018/11/30/11th-dotty-milestone-release.html"><span>Announcing Dotty 0.11.0-RC1</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../../../blog/2018/10/10/10th-dotty-milestone-release.html"><span>Announcing Dotty 0.10.0-RC1</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../../../blog/2018/07/06/ninth-dotty-milestone-release.html"><span>Announcing Dotty 0.9.0-RC1</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../../../blog/2018/04/27/eighth-dotty-milestone-release.html"><span>Announcing Dotty 0.7.0 and 0.8.0-RC1</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../../../blog/2018/03/05/seventh-dotty-milestone-release.html"><span>Announcing Dotty 0.6.0 and 0.7.0-RC1</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../../../blog/2017/12/01/fifth-dotty-milestone-release.html"><span>Announcing Dotty 0.5.0-RC1</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../../../blog/2017/10/16/fourth-dotty-milestone-release.html"><span>Announcing Dotty 0.4.0-RC1</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../../../blog/2017/09/07/third-dotty-milestone-release.html"><span>Announcing Dotty 0.3.0-RC2</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../../../blog/2017/07/12/second-dotty-milestone-release.html"><span>Announcing Dotty 0.2.0-RC1, with new optimizations, improved stability and IDE support</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../../../blog/2017/05/31/first-dotty-milestone-release.html"><span>Announcing Dotty 0.1.2-RC1, a major step towards Scala 3</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../../../blog/2016/12/05/implicit-function-types.html"><span>Implicit Function Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../../../blog/2016/05/05/multiversal-equality.html"><span>Multiversal Equality for Scala</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../../../blog/2016/02/17/scaling-dot-soundness.html"><span>Scaling DOT to Scala - Soundness</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../../../blog/2016/02/03/essence-of-scala.html"><span>The Essence of Scala</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../../../blog/2016/01/02/new-year-resolutions.html"><span>New Year Resolutions</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../../../blog/2015/10/23/dotty-compiler-bootstraps.html"><span>We got liftoff!</span></a></span></div></div></nav></div><div id="footer" class="body-small"><div class="left-container">Generated with</div><div class="right-container"><a href="https://github.com/scala/scala3"><button class="icon-button gh"></button></a><a href="https://discord.com/invite/scala"><button class="icon-button discord"></button></a><a href="https://twitter.com/scala_lang"><button class="icon-button twitter"></button></a><div class="text">Copyright (c) 2002-2025, LAMP/EPFL</div></div><div class="text-mobile">Copyright (c) 2002-2025, LAMP/EPFL</div></div><div id="scaladoc-searchBar"></div><div id="main"><div class="breadcrumbs container"><a href="../../../index.html">Scala 3</a>/<a href="../index.html">Reference</a>/<a href="index.html">Experimental</a>/<a href="into.html">The `into` Type and Modifier</a></div><div id="content" class="body-medium"><div><div id="content-wrapper">
 <div class="site-container">
  <div id="site-header"></div>
  <aside class="warning">
   <div class="icon"></div>
   <div class="content">
    This is a nightly documentation. The content of this page may not be consistent with the current stable version of language. Click <a href="https://docs.scala-lang.org/scala3/reference/experimental/into.html">here</a> to find the stable version of this page.
   </div>
  </aside>
  <main>
   <header>
    <a class="text-button with-link body-small" href="https://github.com/scala/scala3/edit/main/docs/_docs/reference/experimental/into.md">Edit this page on GitHub</a>
    <h1 class="h600">The `into` Type and Modifier</h1>
   </header>
   <p class="body-large first-p">This feature is not yet part of the Scala 3 language definition. It can be made available by a language import:</p>
   <div class="snippet mono-small-block" scala-snippet="">
    <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>import scala.language.experimental.into
</span></code></pre>
    <div class="buttons"></div>
   </div>
   <section id="summary">
    <h2 class="h500"><a href="#summary" class="anchor"></a>Summary</h2>
    <p>Scala 3 offers two alternative schemes to allow implicit conversions using Scala-3's <code>Conversion</code> class without requiring a language import.</p>
    <p>The first scheme is to have a special type <code>into[T]</code> which serves as a marker that conversions into that type are allowed. These types are typically used in parameters of methods that are designed to work with implicit conversions of their arguments. This allows fine-grained control over where implicit conversions should be allowed. We call this scheme "<em>into as a type constructor</em>".</p>
    <p>The second scheme allows <code>into</code> as a soft modifier on traits, classes, and opaque type aliases. If a type definition is declared with this modifier, conversions to that type are allowed. The second scheme requires that one has control over the conversion target types so that an <code>into</code> can be added to their declaration. It is appropriate where there are a few designated types that are meant to be conversion targets. If that's the case, migration from Scala 2 to Scala 3 becomes easier since no function signatures need to be rewritten. We call this scheme "<em>into as a modifier</em>".</p>
   </section>
   <section id="motivation">
    <h2 class="h500"><a href="#motivation" class="anchor"></a>Motivation</h2>
    <p>Scala 3's implicit conversions of the <code>scala.Conversion</code> class require a language import</p>
    <div class="snippet mono-small-block">
     <pre><code class="language-"><span line-number="1" class=""><span class="tooltip-container"></span>import scala.language.implicitConversions
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>in any code that uses them as implicit conversions (code that calls conversions explicitly is not affected). If the import is missing, a feature warning is currently issued, and this will become an error in future versions of Scala 3. The motivation for this restriction is two-fold:</p>
    <ul>
     <li>Code with hidden implicit conversions is hard to understand and might have correctness or performance issues that go undetected.</li>
     <li>If we require explicit user opt-in for implicit conversions, we can significantly improve type inference by propagating expected type information more widely in those parts of the program where there is no opt-in.</li>
    </ul>
    <p>There is one broad use case, however, where implicit conversions are very hard to replace. This is the case where an implicit conversion is used to adapt a method argument to its formal parameter type. An example from the standard library:</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>scala&gt; val xs = List(0, 1)
</span><span line-number="2" class=""><span class="tooltip-container"></span>scala&gt; val ys = Array(2, 3)
</span><span line-number="3" class=""><span class="tooltip-container"></span>scala&gt; xs ++ ys
</span><span line-number="4" class=""><span class="tooltip-container"></span>val res0: List[Int] = List(0, 1, 2, 3)
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>The input line <code>xs ++ ys</code> makes use of an implicit conversion from <code>Array[Int]</code> to <code>IterableOnce[Int]</code>. This conversion is defined in the standard library as an <code>implicit def</code>. Once the standard library is rewritten with Scala 3 conversions, this will require a language import at the use site, which is clearly unacceptable. It is possible to avoid the need for implicit conversions using method overloading or type classes, but this often leads to longer and more complicated code, and neither of these alternatives work for vararg parameters.</p>
   </section>
   <section id="first-scheme-into-as-a-type-constructor">
    <h2 class="h500"><a href="#first-scheme-into-as-a-type-constructor" class="anchor"></a>First Scheme: <code>into</code> as a Type Constructor</h2>
    <p>This is where the <code>into</code> type constructor comes in. Here is a signature of a <code>++</code> method on <code>List[A]</code> that uses it:</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span><span class="hideable">  </span>def ++ (elems: into[IterableOnce[A]]): List[A]
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>The <code>into</code> wrapper on the type of <code>elems</code> means that implicit conversions can be applied to convert the actual argument to an <code>IterableOnce</code> value, and this without needing a language import.</p>
    <p><code>into</code> is defined as follows in the companion object of the <code>scala.Conversion</code> class:</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>opaque type into[T] &gt;: T = T
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>Types of the form <code>into[T]</code> are treated specially during type checking. If the expected type of an expression is <code>into[T]</code> then an implicit conversion to that type can be inserted without the need for a language import.</p>
    <p>Note: Unlike other types, <code>into</code> starts with a lower-case letter. This emphasizes the fact that <code>into</code> is treated specially by the compiler, by making <code>into</code> look more like a keyword than a regular type.</p>
   </section>
   <section id="example-1">
    <h3 class="h400"><a href="#example-1" class="anchor"></a>Example 1</h3>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>given Conversion[Array[Int], IterableOnce[Int]] = wrapIntArray
</span><span line-number="2" class=""><span class="tooltip-container"></span>val xs: List[Int] = List(1)
</span><span line-number="3" class=""><span class="tooltip-container"></span>val ys: Array[Int] = Array(2, 3)
</span><span line-number="4" class=""><span class="tooltip-container"></span>xs ++ ys
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>This inserts the given conversion on the <code>ys</code> argument in <code>xs ++ ys</code>. It typechecks without a feature warning since the formal parameter of <code>++</code> is of type <code>into[IterableOnce]</code>, which is also the expected type of <code>ys</code>.</p>
   </section>
   <section id="example-2">
    <h3 class="h400"><a href="#example-2" class="anchor"></a>Example 2</h3>
    <p>Consider a simple expression AST type:</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>enum Expr:
</span><span line-number="2" class=""><span class="tooltip-container"></span>  case Neg(e: Expr)
</span><span line-number="3" class=""><span class="tooltip-container"></span>  case Add(e1: Expr, e2: Expr)
</span><span line-number="4" class=""><span class="tooltip-container"></span>  case Const(n: Int)
</span><span line-number="5" class=""><span class="tooltip-container"></span>import Expr.*
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>Say we'd like to build <code>Expr</code> trees without explicit <code>Const</code> wrapping, as in <code>Add(1, Neg(2))</code>. The usual way to achieve this is with an implicit conversion from <code>Int</code> to <code>Const</code>:</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>given Conversion[Int, Const] = Const(_)
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>Normally, that would require a language import in all source modules that construct <code>Expr</code> trees. We can avoid this requirement on user code by declaring <code>Neg</code> and <code>Add</code> with <code>into</code> parameters:</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>enum Expr:
</span><span line-number="2" class=""><span class="tooltip-container"></span>  case Neg(e: into[Expr])
</span><span line-number="3" class=""><span class="tooltip-container"></span>  case Add(e1: into[Expr], e2: into[Expr])
</span><span line-number="4" class=""><span class="tooltip-container"></span>  case Const(n: Int)
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>This would allow conversions from <code>Int</code> to <code>Const</code> when constructing trees but not elsewhere.</p>
   </section>
   <section id="into-in-function-results">
    <h3 class="h400"><a href="#into-in-function-results" class="anchor"></a><code>into</code> in Function Results</h3>
    <p><code>into</code> allows conversions everywhere it appears as expected type, including in the results of function arguments. For instance, consider the new proposed signature of the <code>flatMap</code> method on <code>List[A]</code>:</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span><span class="hideable">  </span>def flatMap[B](f: A =&gt; into[IterableOnce[B]]): List[B]
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>This accepts all actual arguments <code>f</code> that, when applied to an <code>A</code>, give a result that is convertible to <code>IterableOnce[B]</code>. So the following would work:</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>scala&gt; val xs = List(1, 2, 3)
</span><span line-number="2" class=""><span class="tooltip-container"></span>scala&gt; xs.flatMap(x =&gt; x.toString * x)
</span><span line-number="3" class=""><span class="tooltip-container"></span>val res2: List[Char] = List(1, 2, 2, 3, 3, 3)
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>Here, the conversion from <code>String</code> to <code>Iterable[Char]</code> is applied on the results of <code>flatMap</code>'s function argument when it is applied to the elements of <code>xs</code>.</p>
   </section>
   <section id="vararg-arguments">
    <h3 class="h400"><a href="#vararg-arguments" class="anchor"></a>Vararg arguments</h3>
    <p>When applied to a vararg parameter, <code>into</code> allows a conversion on each argument value individually. For example, consider a method <code>concatAll</code> that concatenates a variable number of <code>IterableOnce[Char]</code> arguments, and also allows implicit conversions into <code>IterableOnce[Char]</code>:</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>def concatAll(xss: into[IterableOnce[Char]]*): List[Char] =
</span><span line-number="2" class=""><span class="tooltip-container"></span>  xss.foldRight(Nil)(_ ++: _)
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>Here, the call</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>concatAll(List('a'), "bc", Array('d', 'e'))
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>would apply two <em>different</em> implicit conversions: the conversion from <code>String</code> to <code>Iterable[Char]</code> gets applied to the second argument and the conversion from <code>Array[Char]</code> to <code>Iterable[Char]</code> gets applied to the third argument.</p>
   </section>
   <section id="unwrapping-into">
    <h3 class="h400"><a href="#unwrapping-into" class="anchor"></a>Unwrapping <code>into</code></h3>
    <p>Since <code>into[T]</code> is an opaque type, its run-time representation is just <code>T</code>. At compile time, the type <code>into[T]</code> is a known supertype of the type <code>T</code>. So if <code>t: T</code>, then</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span><span class="hideable">  </span>val x: into[T] = t
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>typechecks but</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>val y: T = x   // error
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>is ill-typed. We can recover the underlying type <code>T</code> using the <code>underlying</code> extension method which is also defined in object <code>Conversion</code>:</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>import Conversion.underlying
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>val y: T = x.underlying    // ok
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>However, the next section shows that unwrapping with <code>.underlying</code> is not needed for parameters, which is the most common use case. So explicit unwrapping should be quite rare.</p>
   </section>
   <section id="dropping-into-for-parameters-in-method-bodies">
    <h3 class="h400"><a href="#dropping-into-for-parameters-in-method-bodies" class="anchor"></a>Dropping <code>into</code> for Parameters in Method Bodies</h3>
    <p>The typical use cases for <code>into</code> wrappers are for parameters. Here, they specify that the corresponding arguments can be converted to the formal parameter types. On the other hand, inside a method, a parameter type can be assumed to be of the underlying type since the conversion already took place when the enclosing method was called. This is reflected in the type system which erases <code>into</code> wrappers in the local types of parameters as they are seen in a method body. Here is an example:</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span><span class="hideable">  </span>def ++ (elems: into[IterableOnce[A]]): List[A] =
</span><span line-number="2" class=""><span class="tooltip-container"></span><span class="hideable">  </span>  val buf = ListBuffer[A]()
</span><span line-number="3" class=""><span class="tooltip-container"></span><span class="hideable">  </span>  for elem &lt;- elems.iterator do // no `.underlying` needed here
</span><span line-number="4" class=""><span class="tooltip-container"></span><span class="hideable">  </span>    buf += elems
</span><span line-number="5" class=""><span class="tooltip-container"></span><span class="hideable">  </span>  buf.toList
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>Inside the <code>++</code> method, the <code>elems</code> parameter is of type <code>IterableOnce[A]</code>, not <code>into[IterableOne[A]]</code>. Hence, we can simply write <code>elems.iterator</code> to get at the <code>iterator</code> method of the <code>IterableOnce</code> class.</p>
    <p>Specifically, we erase all <code>into</code> wrappers in the local types of parameter types that appear in covariant or invariant position. Contravariant <code>into</code> wrappers are kept since these typically are on the parameters of function arguments.</p>
   </section>
   <section id="into-constructors-in-type-aliases">
    <h3 class="h400"><a href="#into-constructors-in-type-aliases" class="anchor"></a>Into Constructors in Type Aliases</h3>
    <p>Since <code>into</code> is a regular type constructor, it can be used anywhere, including in type aliases and type parameters. For instance, in the Scala standard library we could define</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>type ToIterator[T] = into[IterableOnce[T]]
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>and then <code>++</code>, <code>flatMap</code> and other functions could use this alias in their parameter types. The effect would be the same as when <code>into</code> is written out explicitly.</p>
   </section>
   <section id="second-scheme-into-as-a-modifier">
    <h2 class="h500"><a href="#second-scheme-into-as-a-modifier" class="anchor"></a>Second Scheme: <code>into</code> as a Modifier</h2>
    <p>The <code>into</code> scheme discussed so far strikes a nice balance between explicitness and convenience. But migrating to it from Scala 2 implicits does require major changes since possibly a large number of function signatures has to be changed to allow conversions on the arguments. This might ultimately hold back migration to Scala 3 implicits.</p>
    <p>To facilitate migration, we also introduce an alternative way to specify target types of implicit conversions. We allow <code>into</code> as a soft modifier on classes, traits, and opaque type aliases. If a type definition is declared with <code>into</code>, then implicit conversions into that type don't need a language import.</p>
    <p>For instance, the Laminar framework defines a trait <code>Modifier</code> that is commonly used as a parameter type of user-defined methods and that should support implicit conversions into it. <code>Modifier</code> is commonly used as a parameter type in both Laminar framework functions and in application-level functions that use Laminar.</p>
    <p>We can support implicit conversions to <code>Modifier</code>s simply by making <code>Modifier</code> an <code>into</code> trait:</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>into trait Modifier ...
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>This means implicit <code>Conversion</code> instances with <code>Modifier</code> results can be inserted without requiring a language import.</p>
    <p>Here is a simplified example:</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>trait Modifier
</span><span line-number="2" class=""><span class="tooltip-container"></span>given Conversion[Option[Node], Modifier] = ...
</span><span line-number="3" class=""><span class="tooltip-container"></span>given Conversion[Seq[Node], Modifier] = ...
</span><span line-number="4" class=""><span class="tooltip-container"></span>
</span><span line-number="5" class=""><span class="tooltip-container"></span>def f(x: Source, m: Modifier) = ...
</span><span line-number="6" class=""><span class="tooltip-container"></span>f(source, Some(node)) // inserts conversion
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>The <code>into</code>-as-a-modifier scheme is handy in codebases that have a small set of specific types that are intended as the targets of implicit conversions defined in the same codebase. Laminar's <code>Modifier</code> is a typical example. But the scheme can be easily abused by making the number of <code>into</code> types too large. One should restrict the number of <code>into</code>-declared types to the absolute minimum. In particular, never make a type <code>into</code> to just cater for the possibility that someone might want to later add an implicit conversion to it.</p>
   </section>
   <section id="details-conversion-target-types">
    <h2 class="h500"><a href="#details-conversion-target-types" class="anchor"></a>Details: Conversion target types</h2>
    <p>To make the preceding descriptions more precise: An implicit conversion is permitted without an <code>implicitConversions</code> language import if the target type is a valid conversion target type. A valid conversion target type is one of the following:</p>
    <ul>
     <li>A type of the form <code>into[T]</code>.</li>
     <li>A reference <code>p.C</code> to a class, trait, or opaque type alias <code>C</code> that is declared with an <code>into</code> modifier. The reference can be followed by type arguments.</li>
     <li>A type alias of a valid conversion target type.</li>
     <li>A match type that reduces to a valid conversion target type.</li>
     <li>An annotated type <code>T @ann</code> where <code>T</code> is a valid conversion target type.</li>
     <li>A refined type <code>T {...}</code> where <code>T</code> is a valid conversion target type.</li>
     <li>A union <code>T | U</code> of two valid conversion target types <code>T</code> and <code>U</code>.</li>
     <li>An intersection <code>T &amp; U</code> of two valid conversion target types <code>T</code> and <code>U</code>.</li>
     <li>An instance of a type parameter that is explicitly instantiated to a valid conversion target type.</li>
    </ul>
    <p>Type parameters that are not fully instantiated do not count as valid conversion target types. For instance, consider:</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>  trait Token
</span><span line-number="2" class=""><span class="tooltip-container"></span>  class Keyword(str: String)
</span><span line-number="3" class=""><span class="tooltip-container"></span>  given Conversion[String, Keyword] = KeyWord(_)
</span><span line-number="4" class=""><span class="tooltip-container"></span>
</span><span line-number="5" class=""><span class="tooltip-container"></span>  List[into[Keyword]]("if", "then", "else")
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>This type-checks since the target type of the list elements is the type parameter of the <code>List.apply</code> method which is explicitly instantiated to <code>into[Keyword]</code>. On the other hand, if we continue the example as follows we get an error:</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span><span class="hideable">  </span>val ifKW: into[Keyword] = "if"
</span><span line-number="2" class=""><span class="tooltip-container"></span><span class="hideable">  </span>val ys: List[into[Keyword]] = List(ifKW, "then", "else")
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>Here, the type variable of <code>List.apply</code> is not explicitly instantiated when we check the <code>List(...)</code> arguments (it is just upper-bounded by the target type <code>into[Keyword]</code>). This is not enough to allow implicit conversions on the second and third arguments.</p>
    <p>Subclasses of <code>into</code> classes or traits do not count as valid conversion target types. For instance, consider:</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>into trait T
</span><span line-number="2" class=""><span class="tooltip-container"></span>class C(x: Int) extends T
</span><span line-number="3" class=""><span class="tooltip-container"></span>given Conversion[Int, C] = C(_)
</span><span line-number="4" class=""><span class="tooltip-container"></span>
</span><span line-number="5" class=""><span class="tooltip-container"></span>def f(x: T) = ()
</span><span line-number="6" class=""><span class="tooltip-container"></span>def g(x: C) = ()
</span><span line-number="7" class=""><span class="tooltip-container"></span>f(1)      // ok
</span><span line-number="8" class=""><span class="tooltip-container"></span>g(1)      // error
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>The call <code>f("abc")</code> type-checks since <code>f</code>'s parameter type <code>T</code> is <code>into</code>. But the call <code>g("abc")</code> does not type-check since <code>g</code>'s parameter type <code>C</code> is not <code>into</code>. It does not matter that <code>C</code> extends a trait <code>T</code> that is <code>into</code>.</p>
   </section>
   <section id="why-two-different-schemes">
    <h2 class="h500"><a href="#why-two-different-schemes" class="anchor"></a>Why Two Different Schemes?</h2>
    <p>Can we make do with just one scheme instead of two? In practice this would be difficult.</p>
    <p>Let's first take a look the <code>Expr</code> example, which uses into-as-a-constructor. Could it be rewritten to use into-as-a-modifier? This would mean we have to add <code>into</code> to the whole <code>Expr</code> enum. Adding it to just <code>Const</code> is not enough, since <code>Add</code> and <code>Neg</code> take <code>Expr</code> arguments, not <code>Const</code> arguments.</p>
    <p>But we might not always have permission to change the <code>Expr</code> enum. For instance, <code>Expr</code> could be defined in a lower level library without implicit conversions, but later we want to make <code>Expr</code> construction convenient by eliding <code>Const</code> wrappers in some higher-level library or application. With <code>into</code> constructors, this is easy: Define the implicit conversion and facade methods that construct <code>Expr</code> trees while taking <code>into[Expr]</code> parameters. With <code>into</code> modifiers there is no way to achieve the same.</p>
    <p>A possibly more important objection is that even if we could add the <code>into</code> modifier to <code>Expr</code>, it would be bad style to do so! We want to allow for implicit conversion in the very specific case where we build an <code>Expr</code> tree using the <code>Add</code> and <code>Neg</code> constructors. Our applications could have lots of other methods that take <code>Expr</code> trees, for instance to analyze them or evaluate them. We probably do not want to allow implicit conversions for the arguments of all these other methods. The <code>into</code> modifier is too unspecific to distinguish the good use case from the problematic ones.</p>
    <p>On the other hand, there are also situations where into-as-a-modifier is the practical choice. To see this, consider again the <code>Modifier</code> use case in Laminar. We could avoid the <code>into</code> modifier by wrapping all <code>Modifier</code> parameters with the <code>into</code> constructor. This would be a lot more work than adding just the single <code>into</code> modifier. Worse, functions taking <code>Modifier</code> parameters are found both in the Laminar framework code and in many applications using it. The framework and the applications would have to be upgraded in lockstep. When Laminar upgrades to Scala 3 implicits, all applications would have to be rewritten, which would make such a migration very cumbersome.</p>
    <p>One can try to mitigate the effort by playing with type aliases. For instance, a hypothetical future Laminar using Scala 3 conversions could rename the trait <code>Modifier</code> to <code>ModifierTrait</code> and define an alias</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>type Modifier = into[ModifierTrait]
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>Then the source code of applications would not have to change (unless these applications define classes directly extending <code>Modifier</code>). But that future Laminar would not be binary compatible with the current one, since the name of the original <code>Modifier</code> trait has changed. In summary, upgrading Laminar to use Scala 3 conversions could keep either source compatibility or binary compatibility but not both at the same time.</p>
   </section>
   <section id="syntax-changes">
    <h2 class="h500"><a href="#syntax-changes" class="anchor"></a>Syntax Changes</h2>
    <div class="snippet mono-small-block">
     <pre><code class="language-"><span line-number="1" class=""><span class="tooltip-container"></span>LocalModifier     ::=  ...  |  ‘into’
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p><code>into</code> is a soft modifier. It is only allowed classes, traits, and opaque type aliases.</p>
   </section>
  </main>
  <div class="divider"></div>
  <nav class="arrow-navigation" aria-label="Page navigation">
   <div>
    <span class="body-small">Previous</span> <a rel="prev" href="main-annotation.html" aria-keyshortcuts="Left" class="body-medium"> <span class="body-medium">MainAnnotation</span> </a>
   </div>
   <div>
    <span class="body-small arrow-navigation--next">Next</span> <a rel="next" href="cc.html" aria-keyshortcuts="Right" class="body-medium"> <span class="body-medium">Capture Checking</span> </a>
   </div>
  </nav>
  <div class="content-contributors hidden">
   <h1 class="h200">Contributors to this page</h1>
   <div id="documentation-contributors" class="contributors-container"></div>
   <div class="github-edit-button">
    <a class="text-button with-link body-small" href="https://github.com/scala/scala3/edit/main/docs/_docs/reference/experimental/into.md"> Edit this page on GitHub </a>
   </div>
  </div>
 </div>
</div></div><div id="toc" class="body-small"><div id="toc-container"><span class="toc-title h200">In this article</span><nav class="toc-nav"><ul class="toc-list"><li><a href="#summary">Summary</a></li><li><a href="#motivation">Motivation</a></li><li><a href="#first-scheme-into-as-a-type-constructor">First Scheme: into as a Type Constructor</a><ul><li><a href="#example-1">Example 1</a></li><li><a href="#example-2">Example 2</a></li><li><a href="#into-in-function-results">into in Function Results</a></li><li><a href="#vararg-arguments">Vararg arguments</a></li><li><a href="#unwrapping-into">Unwrapping into</a></li><li><a href="#dropping-into-for-parameters-in-method-bodies">Dropping into for Parameters in Method Bodies</a></li><li><a href="#into-constructors-in-type-aliases">Into Constructors in Type Aliases</a></li></ul></li><li><a href="#second-scheme-into-as-a-modifier">Second Scheme: into as a Modifier</a></li><li><a href="#details-conversion-target-types">Details: Conversion target types</a></li><li><a href="#why-two-different-schemes">Why Two Different Schemes?</a></li><li><a href="#syntax-changes">Syntax Changes</a></li></ul></nav></div></div></div><div id="footer" class="body-small mobile-footer"><div class="left-container">Generated with</div><div class="right-container"><a href="https://github.com/scala/scala3"><button class="icon-button gh"></button></a><a href="https://discord.com/invite/scala"><button class="icon-button discord"></button></a><a href="https://twitter.com/scala_lang"><button class="icon-button twitter"></button></a><div class="text">Copyright (c) 2002-2025, LAMP/EPFL</div></div><div class="text-mobile">Copyright (c) 2002-2025, LAMP/EPFL</div></div></div></div></body></html>