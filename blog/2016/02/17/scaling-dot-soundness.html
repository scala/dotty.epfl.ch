<html><head><meta charset="utf-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><title>Scaling DOT to Scala - Soundness</title><link rel="shortcut icon" type="image/x-icon" href="../../../../favicon.ico"></link><script type="text/javascript" src="../../../../scripts/clipboard.js" defer="true"></script><script type="text/javascript" src="../../../../scripts/platform-content-handler.js" defer="true"></script><script type="text/javascript" src="../../../../scripts/main.js" defer="true"></script><link rel="stylesheet" href="../../../../styles/nord-light.css"></link><link rel="stylesheet" href="../../../../styles/scalastyle.css"></link><link rel="stylesheet" href="../../../../styles/dotty-icons.css"></link><link rel="stylesheet" href="../../../../styles/diagram.css"></link><link rel="stylesheet" href="../../../../styles/filter-bar.css"></link><link rel="stylesheet" href="../../../../styles/search-bar.css"></link><script type="text/javascript" src="https://code.jquery.com/jquery-3.5.1.min.js" defer="true"></script><script type="text/javascript" src="https://d3js.org/d3.v6.min.js" defer="true"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/graphlib-dot@0.6.2/dist/graphlib-dot.min.js" defer="true"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dagre-d3/0.6.1/dagre-d3.min.js" defer="true"></script><script type="text/javascript" src="../../../../scripts/diagram.js" defer="true"></script><link rel="stylesheet" href="../../../../styles/filter-bar.css"></link><script type="text/javascript" src="../../../../hljs/highlight.pack.js" defer="true"></script><script type="text/javascript" src="../../../../scripts/hljs-scala3.js" defer="true"></script><script type="text/javascript" src="../../../../scripts/ux.js" defer="true"></script><script type="text/javascript" src="../../../../scripts/common/component.js" defer="true"></script><script type="text/javascript" src="../../../../scripts/common/utils.js" defer="true"></script><script type="text/javascript" src="../../../../scripts/components/FilterBar.js" defer="true"></script><script type="text/javascript" src="../../../../scripts/components/DocumentableList.js" defer="true"></script><script type="text/javascript" src="../../../../scripts/components/Input.js" defer="true"></script><script type="text/javascript" src="../../../../scripts/components/FilterGroup.js" defer="true"></script><script type="text/javascript" src="../../../../scripts/components/Filter.js" defer="true"></script><script type="text/javascript" src="../../../../scripts/data.js" defer="true"></script><script type="text/javascript" src="../../../../scripts/fast-navigation-loader.js" defer="true"></script><link rel="stylesheet" href="../../../../css/bootstrap.min.css"></link><link rel="stylesheet" href="../../../../css/dottydoc.css"></link><link rel="stylesheet" href="../../../../css/color-brewer.css"></link><script type="text/javascript" src="../../../../js/jquery.min.js" defer="true"></script><script type="text/javascript" src="../../../../js/bootstrap.min.js" defer="true"></script><script>var pathToRoot = "../../../../";</script></head><body><div id="container"><div id="leftColumn"><div id="logo"><span><img src="../../../../project-logo/logo.svg"></img></span><span><div class="projectName">Scala 3</div></span><span><div class="projectVersion">3.0.0-RC1-bin-20201128-928e01a-NIGHTLY</div></span></div><div id="paneSearch"></div><nav id="sideMenu"></nav></div><div id="main"><div id="leftToggler"><span class="icon-toggler"></span></div><div id="searchBar"></div><main>
  <div id="content" pageIds="_.blog/_posts/2016-02-17-scaling-dot-soundness.md////PointingToDeclaration//-1315330942">
    <div class="breadcrumbs"><a href="../../../../docs/index.html">Scala 3</a>/<a href="../../../index.html">Blog</a>/<a href="scaling-dot-soundness.html">Scaling DOT to Scala - Soundness</a></div>
<html>
 <head>
  <link rel="dns-prefetch" href="//fonts.googleapis.com"> 
  <link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin> 
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin> 
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.9.0/css/all.min.css"> 
 </head>
 <body>
  <div id="content-wrapper"> 
   <main class="container"> 
    <header> 
     <h1>Scaling DOT to Scala - Soundness</h1> 
     <div class="byline"> <time class="date"> <i class="far fa-calendar-alt"></i> 2016-02-17 </time> <span class="author"> <i class="fas fa-pen-nib"></i> Martin Odersky </span> 
     </div> 
    </header> 
    <p>In my <a href="http://www.scala-lang.org/blog/2016/02/03/essence-of-scala.html">last blog post</a> I introduced DOT, a minimal calculus that underlies much of Scala. DOT is much more than an academic exercise, because it gives us guidelines on how to design a sound type system for full Scala.</p> 
    <h2><a href="#recap-the-problem-of-bad-bounds" id="recap-the-problem-of-bad-bounds" class="anchor"></a>Recap: The Problem of Bad Bounds</h2> 
    <p>As was argued in the previous blog post, the danger a path-dependent type system like Scala's faces is inconsistent bounds or aliases. For instance, you might have a type alias</p> 
    <pre><code class="language-scala">type T = String
</code></pre> 
    <p>in scope in some part of the program, but in another part the same type member <code>T</code> is known as</p> 
    <pre><code class="language-scala">type T = Int
</code></pre> 
    <p>If you connect the two parts, you end up allowing assigning a <code>String</code> to an <code>Int</code> and vice versa, which is unsound - it will crash at runtime with a <code>ClassCastException</code>. The problem is that there is no obvious, practical, compile time analysis for DOT or Scala that ensures that all types have good bounds. Types can contain abstract type members with bounds that can be refined elsewhere and several independent refinements might lead together to a bad bound problem. Barring a whole program analysis there is no specific point in the program where we can figure this out straightforwardly.</p> 
    <p>In DOT, the problem is resolved by insisting that every path prefix <code>p</code> of a type <code>p.T</code> is at runtime a concrete value. That way, we only have to check for good bounds when objects are <em>created</em> with <code>new</code>, and that check is easy: When objects are created, we know their class and we can insist that all nested types in that class are aliases or have consistent bounds. So far so good.</p> 
    <h2><a href="#loopholes-caused-by-scaling-up" id="loopholes-caused-by-scaling-up" class="anchor"></a>Loopholes Caused by Scaling Up</h2> 
    <p>But if we want to scale up the DOT result for full Scala, several loopholes open up. These come all down to the fact that the prefix of a type selection might <em>not</em> be a value that's constructed with a <code>new</code> at run time. The loopholes can be classified into three categories:</p> 
    <ol> 
     <li>The prefix value might be lazy, and never instantiated to anything, as in: <pre><code class="language-scala">lazy val p: S = p
... p.T ...
</code></pre> <p>Note that trying to access the lazy value <code>p</code> would result in an infinite loop. But using <code>p</code> in a type does not force its evaluation, so we might never evaluate <code>p</code>. Since <code>p</code> is not initialized with a <code>new</code>, bad bounds for <code>T</code> would go undetected.</p> </li> 
     <li>The prefix value might be initialized to <code>null</code>, as in <pre><code class="language-scala">val p: S = null
... p.T ...
</code></pre> <p>The problem here is similar to the first one. <code>p</code> is not initialized with a <code>new</code> so we know nothing about the bounds of <code>T</code>.</p> </li> 
     <li>The prefix might be a type <code>T</code> in a type projection <code>T # A</code>, where <code>T</code> is not associated with a runtime value.</li> 
    </ol> 
    <p>We can in fact construct soundness issues in all of these cases. Look at the discussion for issues <a href="https://github.com/lampepfl/dotty/issues/50">#50</a> and <a href="https://github.com/lampepfl/dotty/issues/1050">#1050</a> in the <a href="https://github.com/lampepfl/dotty/issues/1050">Dotty</a> repository on GitHub. All issues work fundamentally in the same way: Construct a type <code>S</code> which has a type member <code>T</code> with bad bounds, say:</p> 
    <pre><code class="language-scala">Any &lt;: T &lt;: Nothing
</code></pre> 
    <p>Then, use the left subtyping to turn an expression of type <code>Any</code> into an expression of type <code>T</code> and use the right subtyping to turn that expression into an expression of type <code>Nothing</code>:</p> 
    <pre><code class="language-scala">def f(x: Any): p.T = x
def g(x: p.T): Nothing = x
</code></pre> 
    <p>Taken together, <code>g(f(x))</code> will convert every expression into an expression of type <code>Nothing</code>. Since <code>Nothing</code> is a subtype of every other type, this means you can convert an arbitrary expression to have any type you choose. Such a feat is an impossible promise, of course. The promise is usually broken at run-time by failing with a <code>ClassCastException</code>.</p> 
    <h2><a href="#plugging-the-loopholes" id="plugging-the-loopholes" class="anchor"></a>Plugging the Loopholes</h2> 
    <p>To get back to soundness we need to plug the loopholes. Some of the necessary measures are taken in pull request <a href="https://github.com/lampepfl/dotty/issues/1051">#1051</a>. That pull request</p> 
    <ul> 
     <li>tightens the rules for overrides of lazy values: lazy values cannot override or implement non-lazy values,</li> 
     <li>tightens the rules which lazy values can appear in paths: they must be final and must have concrete types with known consistent bounds,</li> 
     <li>allows type projections <code>T # A</code> only if <code>T</code> is a concrete type with known consistent bounds.</li> 
    </ul> 
    <p>It looks like this is sufficient to plug soundness problems (1) and (3). To plug (2), we need to make the type system track nullability in more detail than we do it now. Nullability tracking is a nice feature in its own right, but now we have an added incentive for implementing it: it would help to ensure type soundness.</p> 
    <p>There's one sub-case of nullability checking which is much harder to do than the others. An object reference <code>x.f</code> might be <code>null</code> at run time because the field <code>f</code> is not yet initialized. This can lead to a soundness problem, but in a more roundabout way than the other issues we have identified. In fact, Scala guarantees that in a program that runs to completion without aborting, every field will eventually be initialized, so every non-null field will have good bounds. Therefore, the only way an initialized field <code>f</code> could cause a soundness problem is if the program in question would never get to initialize <code>f</code>, either because it goes into an infinite loop or because it aborts with an exception or <code>System.exit</code> call before reaching the initialization point of <code>f</code>. It's a valid question whether type soundness guarantees should extend to this class of "strange" programs. We might want to draw the line here and resort to runtime checks or exclude "strange" programs from any soundness guarantees we can give. The research community has coined the term <a href="http://soundiness.org/">soundiness</a> for this kind of approach and has <a href="http://cacm.acm.org/magazines/2015/2/182650-in-defense-of-soundiness/fulltext">advocated</a> for it.</p> 
    <p>The necessary restrictions on type projection <code>T # A</code> are problematic because they invalidate some idioms in type-level programming. For instance, the cute trick of making Scala's type system Turing complete by having it <a href="https://michid.wordpress.com/2010/01/29/scala-type-level-encoding-of-the-ski-calculus/">simulate SK combinators</a> would no longer work since that one relies on unrestricted type projections. The same holds for some of the encodings of type-level arithmetic.</p> 
    <p>To ease the transition, we will continue for a while to allow unrestricted type projections under a flag, even though they are potentially unsound. In the current Dotty compiler, that flag is a language import <code>-language:Scala2Compat</code>, but it could be something different for other compilers, e.g. <code>-unsafe</code>. Maybe we can find rules that are less restrictive than the ones we have now, and are still sound. But one aspect should be non-negotiable: Any fundamental deviations from the principles laid down by DOT needs to be proven mechanically correct just like DOT was. We have achieved a lot with the DOT proofs, so we should make sure not to back-slide. And if the experience of the past 10 years has taught us one thing, it is that the meta theory of type systems has many more surprises in store than one might think. That's why mechanical proofs are essential.</p> 
    <hr> 
    <footer> 
     <img id="author-img" src="images/martin.jpg"> <span id="author-signature"> Martin Odersky </span> 
    </footer> 
   </main> 
  </div> 
  <script>
  ((window.gitter = {}).chat = {}).options = {
    room: 'lampepfl/dotty'
  };
</script> 
  <script src="https://sidecar.gitter.im/dist/sidecar.v1.js" async defer></script>
 </body>
</html>  </div>
</main><footer><span class="go-to-top-icon"><a href="#container"><span class="icon-vertical_align_top"></span>&nbsp;Back to top</a></span>Generated by&nbsp;<a href="https://github.com/lampepfl/dotty/tree/master/scala3doc"><img src="../../../../images/scala3doc_logo.svg" alt="Scala3doc" class="scala3doc_logo"></img></a></footer></div></div><script type="text/javascript" src="../../../../scripts/pages.js"></script><script type="text/javascript" src="../../../../scripts/main.js"></script></body></html>
